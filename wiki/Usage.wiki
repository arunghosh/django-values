#summary How to include the app and use it on your models

= Importing =

Importing is as simple as any other app, simply add it to the import list at the top of models.py. The trick is to make sure you import the base of the package, not `values.models`. This is to prevent a name clash with `django.db.models` and also to make values a bit more distinct from fields.

{{{
from django.db import models
from myproject import values
...
}}}

= Adding values to models =

Values are added to your models right alongside your existing fields and methods. In fact, the syntax used to add a value is nearly identical to that of a field. Simply declare it using Django's standard declarative syntax, making sure to use `values` instead of `models` as the module to use.

{{{
class Thread(models.Model):
    title = models.CharField(maxlength=255)

    popularity_threshold = values.PositiveIntegerValue()

    def is_popular(self):
        return self.posts.count() > Topic.popularity_threshold

class Post(models.Model):
    thread = models.ForeignKey(Thread, related_name='posts')
    author = models.ForeignKey(User)
    body = models.TextField()
}}}

By default, the value description that will be shown in the editor is derived from the attribute name (just like fields). However, also like fields, values may also take a positional argument for a description. This description will be used in the value editor instead of the default, which is based on the attribute name.

{{{
class Product(models.Model):
    name = models.CharField(maxlength=255)
    description = models.TextField()
    price = models.FloatField("Retail Price", max_digits=5, decimal_places=2)
    cost = models.FloatField("Store Cost", max_digits=5, decimal_places=2)

    preferred_markup = values.PercentValue("How much markup I'd like to get for an item")

    @property
    def profit(self):
        return self.price - self.cost

    def should_promote(self):
        return (self.profit / self.cost) > Store.preferred_markup
}}}

= Editing values =

Once values are added to your models, simply start your server and they'll be automatically found and made available to the value editor. Simply point your browser to !http://localhost:8000/admin/values/ (or whatever domain and port your server uses) and edit at your leisure.

*Note:* This will include a screenshot, I just haven't gotten it up here yet.

= Referencing values in Python =

As the above examples demonstrate, Python code can use these values as standard class attributes. Internally, django-values uses descriptors to take these references and return the current value in the proper type, so your code will always get the right value in the right type. This helps keep your model methods clean and concise, by using a notation that already makes perfect sense.

*Note:* Attributes defined using django-values are only available on the model itself, _not on any individual instances_. Attempting to access a value attribute on an instance of your model will raise an `AttributeError`, the same exception that would be thrown if you had never designated the attribute. This is to ensure that programmers don't get confused by referencing an attribute on an object when that attribute doesn't relate to that specific object. Basically, it's my way of enforcing some level of "good" programming practice.